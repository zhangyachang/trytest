## 声明 var

#### 1. ES5有声明意义的关键字

1. var 会存在变量提升
2. function 也有声明变量的作用

当 function 声明的变量和var声明的变量重名时：

**重名时function的变量权重比var声明的要高**



## 作用域

#### 1. 作用域定义及分类

> 作用域：起作用的范围

ES5里的作用域：

1. 全局作用域
2. 函数作用域



#### 2. 知识点

script是最大的作用域，每一个script都是一个作用域

1. 子作用域可以向父作用域找变量，直到找到全局作用域为之，反之不行。
2. 全局变量都是寄存到 window 对象下，如果一个属性的宿主是 window，那么window可以省略。
3. 当一个变量无中生有时，不管在哪个作用域出来的，统统归到 window 下。





## 代码解析顺序

#### 1. 代码的执行顺序

1. 找声明，var / function 声明；只是声明变量，而不包括赋值

2. 执行

   以上两步：都遵循从上至下

   但是执行的时候，遇到等号，先看等号右边
   
   

**注意：**if和for循环中中的大括号中的声明也属于全局的，开始的时候也是先找声明。



```js
一、JavaScript解析顺序
1.(定义) 先解析 var、function、参数
	a) 该步骤的var只定义变量，后面的 = 赋值不解析
	b) 该步骤的函数只定义函数，函数的执行不解析
    c) 重名的只留一个，var和函数命名函数优先

2.(执行) 再从上至下执行其他代码
二、作用域
	1.最大的作用域为script标签；
    2.遇到函数执行产生新的作用域；
    3.产生新的作用域后同样按照定义-执行的规则解析该作用域的代码；
	4.子作用域可以访问父作用域的参数和变量，反之不行；
    5.每个作用域要访问变量时，先从自身找，找不到再往上一级找。
```



#### 2. 函数参数的解析

1. 在定义的步骤时，函数的参数隐藏了定义的过程，并且函数参数的声明和执行是同时执行的。

（其他的所有的逻辑都是在他之后的；在执行的一瞬间是自动生成的）

2. 参数也要算进去 而且参数的赋值在执行的时候就存在了

3. 每一个函数如果不执行 那么里面的东西是不会执行的

4. 当你执行这个函数的时候，解析又会重新上一遍。



执行到这个函数的时候最开始就要给他声明和赋值，其他的靠边站。

```js
var a = 10;
function fn(b){
  	//var 形参 = 实参;
  	alert(b);
}
fn(a);
```

在函数里面再声明一次他的形参 是没有用的 如果给变量重新赋值是生效的 只有给他赋值才可以改变。



#### 3. 函数中 return 在作用域中的表现

> 函数的作用域在函数定义时就决定了它的位置，而不是在执行的时候决定的。只不过这个作用域在执行时才生效。



```js
var a = 1;
function fn(){
  	var b = 5;
  	return function(){
    	b++;
      	alert(b);
  	}
}
fn()();
//6
```



```js
var a = 1;
var b = 2;
function fn() {
    var b = 3;
    return function () {
        console.log(b);
        return function () {
            console.log(this);    //这里的额this是window吗还是在函数内部执行是其他的呢
        };
    }
}
```



#### 4. if 和 for循环中的声明

if和for循环中中的大括号中的声明也属于全局的，开始的时候也是先找声明。





## 闭包

> 闭包形成的两个条件
>
> 1. 函数嵌套函数
> 2. 内部函数引用了外部函数的变量/参数

作用：内部函数使用到的那个  变量/参数  会被永久的保存下来

同一个函数定义，执行多次会产生不同的作用域。



**优点就是缺点：**

1. 使用的那个变量会被保存下来不会被释放（除了刷新页面或关闭页面）
2. 由于闭包的特性，会对内存消耗比较大。



```js
function fn(){								1.fn2
  	var a = 1;								2.fn2 = fn();
  	return function(){									1.var a;
  		alert(++a);  									2. a = 1;
  	}													return 函数
}											fn2()------------> 内部函数执行
var fn2 = fn();											alert(++a)   //2
fn2();  //2												1. a = 2;	
fn2();  //3									fn2()------------> 内部函数执行
fn2();  //4												alert(++a)
var g = fn();											1. a = 3; //3
g();   //2									fn2()----------->  内部函数执行
															alert(++a)  //4 
```





## 严格模式

可以看一下es6的笔记

严格模式下的代码执行时，非常严格。

​	变量不允许无中生有

​	意义：规范代码开发的流畅，逻辑

"use strict";


